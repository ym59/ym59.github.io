<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Building a Lightweight Job Scheduler Prototype</title>
  <meta name="description" content="How I cobbled together a minimal job scheduler and status tracker with Flask, MongoDB, Celery, and Redis. Not glamorous, but surprisingly satisfying.">
  <meta property="og:title" content="Building a Lightweight Job Scheduler Prototype">
  <meta property="og:description" content="How I cobbled together a minimal job scheduler and status tracker with Flask, MongoDB, Celery, and Redis. Not glamorous, but surprisingly satisfying.">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://ym59.github.io/blogs/posts/job-scheduler-prototype.html">
  <meta property="og:image" content="https://ym59.github.io/images/YM.png">
  <meta property="article:published_time" content="Oct 2025">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Building a Lightweight Job Scheduler Prototype">
  <meta name="twitter:description" content="How I cobbled together a minimal job scheduler and status tracker with Flask, MongoDB, Celery, and Redis. Not glamorous, but surprisingly satisfying.">
  <meta name="keywords" content="Job scheduling, Celery, Flask, Redis, MongoDB, WebDev">

  <link rel="icon" href="../../images/YM.ico" />
  <link rel="stylesheet" href="../styles/post-common.css">
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --text:#cbd5e1;
      --muted:#94a3b8;
      --accent:#7dd3fc;
      --accent-2:#60a5fa;
      --glass:rgba(255,255,255,0.03);
      --radius:14px;
      color-scheme:dark;
      font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
    }
    html.light{
      --bg:#f7fafc;
      --card:#ffffff;
      --text:#0b1220;
      --muted:#536171;
      --accent:#0ea5e9;
      --accent-2:#2563eb;
      --glass:rgba(2,6,23,0.05);
      color-scheme:light;
    }

    html,body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      -webkit-font-smoothing:antialiased;
    }
    .container{max-width:900px;margin:0 auto;padding:28px 20px}
    h1{color:var(--accent-2)}
    .meta{color:var(--muted);font-size:0.95rem;margin-bottom:14px}
    .tags{margin-top:18px}
    .tag{display:inline-block;background:var(--glass);padding:6px 10px;border-radius:999px;margin-right:8px;color:var(--accent);border:1px solid rgba(125,211,252,0.15)}
    a.home{display:inline-block;margin-top:18px;color:var(--accent-2);text-decoration:none}
    a.home:hover{text-decoration:underline}
    .content{line-height:1.75;color:var(--text)}
    .callout{background:var(--card);border:1px solid var(--glass);padding:12px 14px;border-radius:10px}

    .post-top{display:flex;align-items:center;gap:12px;margin-bottom:6px}
    .spacer{flex:1}

	.theme-toggle{
	  width:40px;
	  height:40px;
	  padding:0;
	  border-radius:10px;
	  cursor:pointer;
	  border:1px solid var(--glass);
	  background:transparent;
	  display:inline-flex;
	  align-items:center;
	  justify-content:center;
	  color:var(--muted);
	  line-height:0;           /* no extra baseline space */
	  /* no overflow hidden here */
	  box-sizing:border-box;
	}
	.theme-toggle svg{
	  width:22px;              /* a bit larger but still safe */
	  height:22px;
	  display:block;           /* removes baseline offset */
	  overflow:visible;        /* allow stroke to extend outside viewBox */
	}
  </style>
</head>
<body>
  <div class="container">
    <div class="post-top">
      <a href="../nav.html" class="home">← Back to blog</a>
      <div class="spacer"></div>

    <button class="theme-toggle" id="themeToggle" aria-pressed="false" title="Toggle theme">
	  <svg id="sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
		   fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round">
		<circle cx="12" cy="12" r="4"></circle>
		<path d="M12 2v2m0 16v2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M2 12h2m16 0h2M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41"></path>
	  </svg>
	  <svg id="moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
		   fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round" style="display:none">
		<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
	  </svg>
	</button>
    </div>
    <h1>Building a Lightweight Job Scheduler Prototype</h1>
    <div class="meta">Published: 23 Sep 2025 • Author: Yash Mathur</div>

    <div class="content">

      <h3>Why build something this unglamorous?</h3>
      <p>
        Not every experiment starts with a big, shiny idea. Sometimes you just need a clean way to queue jobs, check their status, and return results without spinning up a monster stack. 
        This project was exactly that: a lightweight prototype to test job submission, asynchronous processing, and real-time status updates.
      </p>
      <p>
        It uses Flask as the front door, MongoDB to keep track of jobs, Redis as the broker, and Celery as the workhorse. 
        Think of it as a quiet little assembly line, where each job checks in, gets processed, and eventually walks out wearing either a green “DONE” badge or a red “FAILED” one.
      </p>

      <h3>The core loop</h3>
      <p>
        The basic flow is straightforward. A file upload triggers a POST endpoint, which generates a unique job ID and writes an entry to MongoDB. 
        The task is then shipped off to Celery via Redis. 
        Meanwhile, a polling loop on the frontend quietly refreshes the job board every few seconds, giving users the illusion that something fancy and real-time is happening in the background.
      </p>
      <p>
        When the Celery worker finishes, it updates the record in MongoDB, marking the job as <code>DONE</code> or <code>FAILED</code>. 
        The frontend reflects that change instantly, turning the status badge into something appropriately smug or tragic.
      </p>

      <h3>UI? Just enough to work</h3>
      <p>
        I didn’t want to over-engineer the interface for a test. 
        A simple HTML/JS frontend with a job list, polling every three seconds, was enough to simulate a proper dashboard. 
        Clicking a job opens a modal with its details and, if successful, a download link to the processed file. 
        No frameworks, no React, just barebones DOM manipulation and CSS badges that look more cheerful than they have any right to.
      </p>

      <h3>The Celery chaos</h3>
      <p>
        Celery is a bit like a moody roommate. Brilliant when it works, occasionally dramatic when it doesn’t. 
        The main hiccup was coordinating the Redis broker, result backend, and ensuring the workers didn’t throw cryptic tantrums when idle. 
        This is where well-scoped environment variables saved the day—clean broker URLs, predictable ports, and no hardcoded mess.
      </p>

      <h3>Scheduling and status checking</h3>
      <p>
        This whole build was meant to stress test the scheduling and status monitoring part of a larger project. 
        Jobs had to be queued, tracked, and surfaced with minimal delay. 
        MongoDB’s simplicity here was a quiet blessing: just write once, update once, and query without ceremony. 
        Add a little timestamp sorting, and you’ve got a functioning mini job board.
      </p>

      <div class="callout">
        It’s the kind of invisible infrastructure that no one claps for, but everything collapses without it.
      </div>

      <h3>Lessons from a quiet prototype</h3>
      <p>
        I didn’t set out to build a polished system, but by the end I had a clean workflow:
      </p>
      <ul>
        <li>Flask for receiving jobs and serving UI</li>
        <li>MongoDB for tracking status</li>
        <li>Redis + Celery for background processing</li>
        <li>A dead simple frontend that tells you when things blow up</li>
      </ul>
      <p>
        Most importantly, I now have a working foundation for future builds. 
        When the big project comes knocking, the bones of this little scheduler will already be battle-tested.
      </p>
    </div>

    <div class="tags">
      <span class="tag">Flask</span><span class="tag">Celery</span><span class="tag">Redis</span><span class="tag">MongoDB</span><span class="tag">Job Scheduling</span>
    </div>
    <p style="margin-top:36px;color:#94a3b8">
      Share: <a href="https://ym59.github.io/blogs/posts/job-scheduler-prototype.html">
      https://ym59.github.io/blogs/posts/job-scheduler-prototype.html</a>
    </p>
  </div>
  <script>
    (function(){
      const root=document.documentElement;
      const toggleBtn=document.getElementById('themeToggle');
      const sun=document.getElementById('sun');
      const moon=document.getElementById('moon');

      function setTheme(mode){
        if(mode==='light'){
          root.classList.add('light');
          toggleBtn?.setAttribute('aria-pressed','true');
          sun.style.display='none'; moon.style.display='block';
          localStorage.setItem('site-theme','light');
        }else{
          root.classList.remove('light');
          toggleBtn?.setAttribute('aria-pressed','false');
          sun.style.display='block'; moon.style.display='none';
          localStorage.setItem('site-theme','dark');
        }
      }

      const saved=localStorage.getItem('site-theme');
      const prefersLight=window.matchMedia('(prefers-color-scheme: light)').matches;
      setTheme(saved ? saved : (prefersLight ? 'light' : 'dark'));

      toggleBtn?.addEventListener('click',()=>{
        const next=document.documentElement.classList.contains('light')?'dark':'light';
        setTheme(next);
      });
    })();
  </script>
</body>
</html>


